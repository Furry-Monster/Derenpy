//! Ren'Py translation file generator with MD5-based identifiers

use anyhow::{Context, Result};
use regex::Regex;
use std::collections::{HashMap, HashSet};
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

use crate::utils::{is_code_like, is_renpy_keyword, unquote};

#[derive(Debug, Clone)]
pub struct DialogueEntry {
    pub identifier: String,
    pub line_number: usize,
    pub character: Option<String>,
    pub original_text: String,
    pub translated_text: Option<String>,
}

#[derive(Debug, Clone)]
pub struct StringEntry {
    pub original: String,
    pub translated: Option<String>,
}

pub struct RenpyTranslationGenerator {
    language: String,
    dialogue_re: Regex,
    label_re: Regex,
}

impl RenpyTranslationGenerator {
    pub fn new(language: &str) -> Self {
        Self {
            language: language.to_string(),
            dialogue_re: Regex::new(
                r#"^\s*(\w+)?\s*("[^"\\]*(?:\\.[^"\\]*)*"|'[^'\\]*(?:\\.[^'\\]*)*')"#,
            )
            .unwrap(),
            label_re: Regex::new(r#"^label\s+(\w+)"#).unwrap(),
        }
    }

    pub fn extract_dialogues<P: AsRef<Path>>(&self, path: P) -> Result<Vec<DialogueEntry>> {
        let content = fs::read_to_string(path.as_ref()).context("Failed to read script file")?;

        let mut entries = Vec::new();
        let mut current_label = "script".to_string();
        let mut used_identifiers: HashSet<String> = HashSet::new();

        for (line_num, line) in content.lines().enumerate() {
            let line_number = line_num + 1;
            let trimmed = line.trim();

            if trimmed.is_empty() || trimmed.starts_with('#') {
                continue;
            }

            if let Some(caps) = self.label_re.captures(trimmed) {
                current_label = caps
                    .get(1)
                    .map(|m| m.as_str().to_string())
                    .unwrap_or_default();
                continue;
            }

            if is_renpy_keyword(trimmed) {
                continue;
            }

            if let Some(caps) = self.dialogue_re.captures(line) {
                let character = caps.get(1).map(|m| m.as_str().to_string());
                let text = caps.get(2).map(|m| m.as_str()).unwrap_or("");
                let original_text = unquote(text);

                if original_text.is_empty() || is_code_like(&original_text) {
                    continue;
                }

                let code_line = Self::build_code_line(character.as_deref(), text);
                let digest = Self::md5_digest(&code_line);
                let identifier =
                    Self::unique_identifier(&current_label, &digest, &mut used_identifiers);

                entries.push(DialogueEntry {
                    identifier,
                    line_number,
                    character,
                    original_text,
                    translated_text: None,
                });
            }
        }

        Ok(entries)
    }

    fn build_code_line(character: Option<&str>, text: &str) -> String {
        match character {
            Some(c) => format!("{} {}", c, text),
            None => text.to_string(),
        }
    }

    fn md5_digest(code: &str) -> String {
        use std::fmt::Write;
        let input = format!("{}\r\n", code);
        let digest = md5::compute(input.as_bytes());
        let mut hex = String::with_capacity(8);
        for byte in &digest.0[..4] {
            write!(hex, "{:02x}", byte).unwrap();
        }
        hex
    }

    fn unique_identifier(label: &str, digest: &str, used: &mut HashSet<String>) -> String {
        let base = format!("{}_{}", label, digest);

        if !used.contains(&base) {
            used.insert(base.clone());
            return base;
        }

        let mut i = 1;
        loop {
            let candidate = format!("{}_{}", base, i);
            if !used.contains(&candidate) {
                used.insert(candidate.clone());
                return candidate;
            }
            i += 1;
        }
    }

    pub fn generate_translation_file(
        &self,
        dialogues: &[DialogueEntry],
        source_file: &str,
    ) -> String {
        let mut output = String::new();

        output.push_str(&format!("# Translation file for {}\n", self.language));
        output.push_str("# Generated by Derenpy\n\n");

        for entry in dialogues {
            output.push_str(&format!("# {}:{}\n", source_file, entry.line_number));
            output.push_str(&format!(
                "translate {} {}:\n",
                self.language, entry.identifier
            ));

            let escaped_original = Self::escape_string(&entry.original_text);
            if let Some(ref char) = entry.character {
                output.push_str(&format!("    # {} \"{}\"\n", char, escaped_original));
            } else {
                output.push_str(&format!("    # \"{}\"\n", escaped_original));
            }

            let translated = entry
                .translated_text
                .as_ref()
                .unwrap_or(&entry.original_text);
            let escaped_translated = Self::escape_string(translated);

            if let Some(ref char) = entry.character {
                output.push_str(&format!("    {} \"{}\"\n", char, escaped_translated));
            } else {
                output.push_str(&format!("    \"{}\"\n", escaped_translated));
            }

            output.push('\n');
        }

        output
    }

    fn escape_string(s: &str) -> String {
        s.replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n")
            .replace('\r', "\\r")
            .replace('\t', "\\t")
    }

    pub fn generate_strings_file(&self, strings: &[StringEntry]) -> String {
        let mut output = String::new();
        let mut seen = HashSet::new();

        output.push_str(&format!("# String translations for {}\n", self.language));
        output.push_str("# Generated by Derenpy\n\n");

        output.push_str(&format!("translate {} strings:\n\n", self.language));

        for entry in strings {
            if seen.contains(&entry.original) {
                continue;
            }
            seen.insert(entry.original.clone());

            let escaped_original = Self::escape_string(&entry.original);
            output.push_str(&format!("    old \"{}\"\n", escaped_original));

            let translated = entry.translated.as_ref().unwrap_or(&entry.original);
            let escaped_translated = Self::escape_string(translated);
            output.push_str(&format!("    new \"{}\"\n\n", escaped_translated));
        }

        output
    }

    pub fn write_translation_files<P: AsRef<Path>>(
        &self,
        output_dir: P,
        dialogues: &HashMap<PathBuf, Vec<DialogueEntry>>,
        strings: &[StringEntry],
    ) -> Result<Vec<PathBuf>> {
        let tl_dir = output_dir.as_ref().join("tl").join(&self.language);
        fs::create_dir_all(&tl_dir).context("Failed to create translation directory")?;

        let mut created_files = Vec::new();

        // Write dialogue files
        for (source_path, entries) in dialogues {
            if entries.is_empty() {
                continue;
            }

            let filename = source_path
                .file_name()
                .unwrap_or_default()
                .to_string_lossy();

            let output_path = tl_dir.join(filename.as_ref());
            let source_str = source_path.to_string_lossy();
            let content = self.generate_translation_file(entries, &source_str);

            let mut file =
                fs::File::create(&output_path).context("Failed to create translation file")?;
            file.write_all(content.as_bytes())
                .context("Failed to write translation file")?;

            created_files.push(output_path);
        }

        // Write strings file
        if !strings.is_empty() {
            let strings_path = tl_dir.join("strings.rpy");
            let content = self.generate_strings_file(strings);

            let mut file =
                fs::File::create(&strings_path).context("Failed to create strings file")?;
            file.write_all(content.as_bytes())
                .context("Failed to write strings file")?;

            created_files.push(strings_path);
        }

        Ok(created_files)
    }
}
